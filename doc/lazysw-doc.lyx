#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Lazy for the Semantic Web
\end_layout

\begin_layout Author
G.
 Falquet
\end_layout

\begin_layout Standard
Lazy is a language and system to publish databases on the Web and to create
 Web application interfaces.
 Lazy creates a hypertext view over a (network of) relational or RDF database(s).
 A hypertext view is a set of nodes (the Web pages) and hyperlinks that
 represent the contents of the database.
 In the declarative approach, the hypertext components (nodes and links)
 are derived from the database content (relation tuples) according to a
 hypertext view specification, as shown below.
\end_layout

\begin_layout Standard
A hypertext view specification consists of a set of 
\emph on
node schemas
\emph default
.
 Every node (Web page) is an instance of a node schema written in the Lazy
 specification language.
 Node instances are dynamically generated by a node server that takes as
 input a compiled formed of the node schemas.
 A node schema specifies: the data source from which the node's content
 is to be drawn (RDF graphs or relational tables), the selection and ordering
 criteria, the elements that form the node content, and links to other nodes.
 The node definition language in the following sections.
 The node schemas must be compiled to be usable by the node server.
 The compilation process first checks the schema's syntax, then translates
 it into a form (in fact SQL queries) that is directly executable by the
 node server.
\end_layout

\begin_layout Standard
Node schemas are organized in modules, called projects.
 Each project has a data source which is either a SQL database or a SPARQL
 endpoint.
\end_layout

\begin_layout Section
Declaring a SPARQL project
\end_layout

\begin_layout Standard
Currently the project name must start with 
\family typewriter
SPARQL_
\family default
 .
\end_layout

\begin_layout Standard
The project must have a String named 
\series bold

\begin_inset Quotes eld
\end_inset

prefix:
\begin_inset Quotes erd
\end_inset


\series default
 that contains the prefixes to be used for all the project queries.
 A typical value for this string would be:
\end_layout

\begin_layout LyX-Code
PREFIX owl: <http://www.w3.org/2002/07/owl#> 
\end_layout

\begin_layout LyX-Code
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
\end_layout

\begin_layout LyX-Code
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
\end_layout

\begin_layout LyX-Code
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
\end_layout

\begin_layout LyX-Code
PREFIX foaf: <http://xmlns.com/foaf/0.1/> 
\end_layout

\begin_layout LyX-Code
PREFIX dc: <http://purl.org/dc/elements/1.1/> 
\end_layout

\begin_layout LyX-Code
PREFIX skos: <http://www.w3.org/2004/02/skos/core#> 
\end_layout

\begin_layout LyX-Code
PREFIX dbo: <http://dbpedia.org/ontology/>
\end_layout

\begin_layout Standard
The database connection of the project must contain the iri of the sparql
 enpoint to query, e.g.
 http://dbpedia.org/sparql .
\end_layout

\begin_layout Section
Declaring nodes
\end_layout

\begin_layout Standard
The general structure of a node is similar to the structure of a relational
 node.
 The syntax is
\end_layout

\begin_layout LyX-Code
'node' NodeName '[' ParameterList ']'
\end_layout

\begin_layout LyX-Code
   Content
\end_layout

\begin_layout LyX-Code
'from' [ ['named'] iri]
\end_layout

\begin_layout LyX-Code
  ['select'] ['distinct'] '{' GroupGraphPattern '}'
\end_layout

\begin_layout LyX-Code
  ['group by' GroupCondition+ ['having' HavingCondition+] ]
\end_layout

\begin_layout LyX-Code
  ['order by' OrderCondition+ ]
\end_layout

\begin_layout LyX-Code
['limit' NumberOrParameter 'offset' NumberOrParameter]
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
The following node displays 20 luxury cars from dbpedia
\end_layout

\begin_layout LyX-Code
node luxury_cars 
\end_layout

\begin_layout LyX-Code
  <h2>("This node represents all luxury cars"),
\end_layout

\begin_layout LyX-Code
  <ul>({ <li>( ?name," is manufactured by - ",?manufacturer) }) 
\end_layout

\begin_layout LyX-Code
from {
\end_layout

\begin_layout LyX-Code
    ?car <http://purl.org/dc/terms/subject>
\end_layout

\begin_layout LyX-Code
           <http://dbpedia.org/resource/Category:Luxury_vehicles> .
\end_layout

\begin_layout LyX-Code
    ?car foaf:name ?name .
\end_layout

\begin_layout LyX-Code
    ?car dbo:manufacturer ?man .
\end_layout

\begin_layout LyX-Code
    ?man foaf:name ?manufacturer 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
limit 20
\end_layout

\begin_layout Standard
The non-terminals  
\emph on
GroupGraphPattern
\emph default
, 
\emph on
GroupCondition
\emph default
, etc.
 are defined as in the SPARQL 1.1 definition (http://www.w3.org/TR/sparql11-query/)
 with a little extension allowing variables to be 
\end_layout

\begin_layout Itemize
usual SPARQL variables: ?
\emph on
identifier
\end_layout

\begin_layout Itemize
node parameters: 
\emph on
identifier
\end_layout

\begin_layout Itemize
lazy system variables [
\emph on
identifier
\emph default
], e.g.
 
\family typewriter
[USER]
\end_layout

\begin_layout Itemize
lazy project internationalized strings [?
\emph on
identifier
\emph default
] 
\end_layout

\begin_layout Standard
Parameters may appear anywhere in a node declaration.
 Their actual value is either a literal (
\begin_inset Quotes eld
\end_inset

xyz
\begin_inset Quotes erd
\end_inset

^^type) or a URI (<xyz>).
 This differs from the relational implementation in which parameters are
 always considered as strings.
 
\end_layout

\begin_layout Standard
Example: display 
\begin_inset Formula $n$
\end_inset

 classes that have a name in Spanish, together with 3 instances of each
 class.
\end_layout

\begin_layout LyX-Code
node OWLClasses[n] 
\end_layout

\begin_layout LyX-Code
<h2>(n, " classes with a name in Spanish"), 
\end_layout

\begin_layout LyX-Code
<ul>(
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
   <li>(str(?cname), concat(" IRI: ", ?c)
\end_layout

\begin_layout LyX-Code
      , " ",  include SomeInstancesOf[?c]
\end_layout

\begin_layout LyX-Code
       )
\end_layout

\begin_layout LyX-Code
  })
\end_layout

\begin_layout LyX-Code
from   distinct {
\end_layout

\begin_layout LyX-Code
    ?c a owl:Class .
 ?c rdfs:label ?cname .
\end_layout

\begin_layout LyX-Code
    FILTER ( lang(?cname) = "es" )
\end_layout

\begin_layout LyX-Code
} limit n
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
node SomeInstancesOf[cls]
\end_layout

\begin_layout LyX-Code
<ul>(
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
   <li>(?x)
\end_layout

\begin_layout LyX-Code
  })
\end_layout

\begin_layout LyX-Code
from { ?x a cls } 
\end_layout

\begin_layout LyX-Code
limit 3
\end_layout

\begin_layout Subsubsection*
\begin_inset Quotes eld
\end_inset

LIMIT
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

OFFSET
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
In the official SPARQL syntax, the limit and offset values must be integer
 constants ([0-9]+).
 No function application is allowed.
 To circumvent this problem, when a parameter appears in a limit or offset
 clause it is automatically converted to its numerical value, as in the
 following example
\end_layout

\begin_layout LyX-Code
node ConceptsSlice[f,lim] 
\end_layout

\begin_layout LyX-Code
<h2>("All Concepts"),  
\end_layout

\begin_layout LyX-Code
<ul>(
\end_layout

\begin_layout LyX-Code
   {    <li>(?k, " ")   }
\end_layout

\begin_layout LyX-Code
    ), 
\end_layout

\begin_layout LyX-Code
<p>(href ConceptsSlice[f+lim,lim]("next"))
\end_layout

\begin_layout LyX-Code
from distinct {?s a ?k } 
\end_layout

\begin_layout LyX-Code
order by ?k 
\end_layout

\begin_layout LyX-Code
limit lim offset f
\end_layout

\begin_layout Section
Formal Specification
\end_layout

\begin_layout Standard
A node definition node n[P] contentPart fromPart is translated to
\end_layout

\begin_layout Itemize
an output template string Out
\end_layout

\begin_layout Itemize
a query template string Query
\end_layout

\begin_layout Standard
Instantiation of a node with parameter values 
\begin_inset Formula $v_{1},\ldots,v_{k}$
\end_inset

.
 The parameter values are character sequences that represent RDF nodes according
 to the RDF/SPARQL syntax, either literal (number or 
\begin_inset Quotes eld
\end_inset

string
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

lexical-form
\begin_inset Quotes erd
\end_inset

^^type or NIL or true/false) or resources (<iri> or prefix:suffix).
 The node content is obtained as follows
\end_layout

\begin_layout Enumerate
the parameter placeholders in the query template are replaced by the parameter
 values.
\end_layout

\begin_layout Enumerate
the query is executed
\end_layout

\begin_layout Enumerate
for each query answer (variable assignment) the output template is instantiated
 by replacing the SPARQL variable placeholders by their value in the answer
 and each parameter or Lazy variable by its value
\end_layout

\begin_layout Section
Developments
\end_layout

\begin_layout Subsection
Projects with multiple endpoints
\end_layout

\begin_layout Enumerate
if a project has endpoints 
\begin_inset Formula $ep_{1},ep_{2},\ldots,ep_{n}$
\end_inset

, each query is sent to all the endpoints and the results are aggregated
 (with duplicate removal).
 
\end_layout

\begin_layout Enumerate
before sending it to an endpoint, the query must be mapped to the e.p.
 vocabulary
\end_layout

\begin_layout Enumerate
the node compiler must check wether the node specification can be exactly
 mapped to each of the project endpoint.
 If not, the node specification must be modified (we want exact queries).
 For instance, some variables must appear in an OPTIONAL part.
\end_layout

\begin_layout Enumerate
for each project there is a vocabulary and a set of mappings to the endpoint
 vocabularies
\end_layout

\begin_layout Subsection
Project dictionary
\end_layout

\begin_layout Standard
Entries have the following syntax
\end_layout

\begin_layout Standard
prop-name -> ep1, ..., epn : prop-expression (with |, /, etc.) ; ...
\end_layout

\begin_layout Standard
class-name -> ep1, ..., epn : class name or subquery
\end_layout

\begin_layout Subsection
Projects with keywords
\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
