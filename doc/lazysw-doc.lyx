#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Lazy for the Semantic Web
\end_layout

\begin_layout Author
G.
 Falquet
\end_layout

\begin_layout Section
Declaring a SPARQL project
\end_layout

\begin_layout Standard
Currently the project name must start with SPARQL_ .
\end_layout

\begin_layout Standard
The project must have a String named 
\series bold

\begin_inset Quotes eld
\end_inset

prefix:
\begin_inset Quotes erd
\end_inset


\series default
 that contains the prefixes to be used for all the project queries.
 A typical value for this string would be:
\end_layout

\begin_layout LyX-Code
PREFIX owl: <http://www.w3.org/2002/07/owl#> 
\end_layout

\begin_layout LyX-Code
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
\end_layout

\begin_layout LyX-Code
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
\end_layout

\begin_layout LyX-Code
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
\end_layout

\begin_layout LyX-Code
PREFIX foaf: <http://xmlns.com/foaf/0.1/> 
\end_layout

\begin_layout LyX-Code
PREFIX dc: <http://purl.org/dc/elements/1.1/> 
\end_layout

\begin_layout LyX-Code
PREFIX dbpedia2: <http://dbpedia.org/property/> 
\end_layout

\begin_layout LyX-Code
PREFIX dbpedia: <http://dbpedia.org/> 
\end_layout

\begin_layout LyX-Code
PREFIX skos: <http://www.w3.org/2004/02/skos/core#> 
\end_layout

\begin_layout LyX-Code
PREFIX dbo: <http://dbpedia.org/ontology/>
\end_layout

\begin_layout Standard
The database connection of the project must contain the iri of the sparql
 enpoint to query, e.g.
 http://dbpedia.org/sparql .
\end_layout

\begin_layout Section
Declaring nodes
\end_layout

\begin_layout Standard
The general structure of a node is similar to the structure of a relational
 node.
 The syntax is
\end_layout

\begin_layout LyX-Code
'node' NodeName '[' ParameterList ']'
\end_layout

\begin_layout LyX-Code
   Content
\end_layout

\begin_layout LyX-Code
'from' [ ['named'] iri]
\end_layout

\begin_layout LyX-Code
  ['select'] ['distinct'] '{' GroupGraphPatternX '}'
\end_layout

\begin_layout LyX-Code
  ['group by' GroupConditionX+ ['having' HavingConditionX+] ]
\end_layout

\begin_layout LyX-Code
  ['order by' OrderConditionX+ ]
\end_layout

\begin_layout LyX-Code
['limit' NumberOrParameter 'offset' NumberOrParameter]
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
The non-terminals  GroupGraphPatternX, GroupConditionX, etc.
 are defined as in the SPARQL 1.1 definition, with the Var non terminal defined
 as augmented with ParameterIdentifier and '[' SystemParameter ']' 
\end_layout

\begin_layout Standard
Parameters may appear anywhere in a node declaration.
 Their actual value is always a string.
 In the display part and in the from part they must be explicitly converted
 to numeric values when necessary.
 For instance with the xsd:decimal() function.
\end_layout

\begin_layout Standard
Limit and offset
\end_layout

\begin_layout Standard
In the official SPARQL syntax, the limit and offset values must be integer
 constants ([0-9]+).
 No function application is allowed.
 To circumvent this problem, when a parameter appears in a limit or offset
 clause it is automatically converted to its numerical value.
 
\end_layout

\begin_layout Section
Formal Specification
\end_layout

\begin_layout Standard
A node definition node n[P] contentPart fromPart is translated to
\end_layout

\begin_layout Itemize
an output template string Out
\end_layout

\begin_layout Itemize
a query template string Query
\end_layout

\begin_layout Standard
Instantiation of a node with parameter values 
\begin_inset Formula $v_{1},\ldots,v_{k}$
\end_inset

.
 The parameter values are character sequences that represent RDF nodes according
 to the RDF/SPARQL syntax, either literal (number or 
\begin_inset Quotes eld
\end_inset

string
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

lexical-form
\begin_inset Quotes erd
\end_inset

^^type or NIL or true/false) or resources (<iri> or prefix:suffix).
 The node content is obtained as follows
\end_layout

\begin_layout Enumerate
the parameter placeholders in the query template are replaced by the parameter
 values.
\end_layout

\begin_layout Enumerate
the query is executed
\end_layout

\begin_layout Enumerate
for each query answer (variable assignment) the output template is instantiated
 as follows
\end_layout

\begin_deeper
\begin_layout Enumerate
variable/parameter placeholders are replaced by the output form of the correspon
ding variable/parameter if they appear as first level simple expressions
 that are not arguments of a node in a link construct.
 Otherwise they are replaced by their SPARQL value
\end_layout

\end_deeper
\begin_layout Section
Developments
\end_layout

\begin_layout Subsection
Projects with multiple endpoints
\end_layout

\begin_layout Enumerate
if a project has endpoints 
\begin_inset Formula $ep_{1},ep_{2},\ldots,ep_{n}$
\end_inset

, each query is sent to all the endpoints and the results are aggregated
 (with duplicate removal).
 
\end_layout

\begin_layout Enumerate
before sending it to an endpoint, the query must be mapped to the e.p.
 vocabulary
\end_layout

\begin_layout Enumerate
the node compiler must check wether the node specification can be exactly
 mapped to each of the project endpoint.
 If not, the node specification must be modified (we want exact queries).
 For instance, some variables must appear in an OPTIONAL part.
\end_layout

\begin_layout Enumerate
for each project there is a vocabulary and a set of mappings to the endpoint
 vocabularies
\end_layout

\begin_layout Subsection
Projects with keywords
\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
